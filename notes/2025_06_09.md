# Supabase Social App Architecture: A Development Log

**Date:** June 10, 2025
**Session Goal:** Design and build a secure, scalable backend for a social application using Supabase, focusing on a follow system, data management via RPCs, and performance.

### Overview of Today's Accomplishments

Today, we designed and built a comprehensive backend for a social application. We started with a simple `follows` table and progressively evolved it into a secure, RPC-driven system. We implemented features like private profiles, follow requests, efficient data fetching, and high-performance search. Along the way, we also debugged several common issues related to SQL, networking (CORS), and client-side data handling, solidifying a robust architectural pattern for your application.

### Table of Contents
1.  **The Instagram-Style Follow System**
    * 1.1. Initial Table Design
    * 1.2. Evolving to Private Profiles & Follow Requests
    * 1.3. Securing with Row Level Security (RLS)
2.  **The Power of Server-Side Logic: PostgreSQL Functions (RPCs)**
    * 2.1. Why Use RPCs? A Best Practice Primer
    * 2.2. RPCs for Core Actions (Following & Goal Management)
    * 2.3. RPCs for Advanced Data Fetching (Profiles & Search)
3.  **Client-Side Integration (React)**
    * 3.1. The RPC-Driven Data Flow
    * 3.2. Refactoring the `ProfilePage`
    * 3.3. Refactoring the `ManageGoalsPage`
4.  **Key Supabase Functionality & Debugging**
    * 4.1. Using `pg_trgm` for Fast Search
    * 4.2. Debugging Common Errors

---

## 1. The Instagram-Style Follow System

We started with the core requirement of tracking followers and evolved it into a complete system with privacy controls.

### 1.1. Initial Table Design

The foundation is a simple **join table** named `follows` that connects two users from your `profiles` table.

```sql
-- Initial "follows" table schema
CREATE TABLE public.follows (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  follower_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  following_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  CONSTRAINT follows_unique_relation UNIQUE (follower_id, following_id)
);
```

### 1.2. Evolving to Private Profiles & Follow Requests

To handle private profiles and follow requests, we made two crucial schema changes:

1.  **Added a privacy flag to `profiles`**:
    ```sql
    ALTER TABLE public.profiles
    ADD COLUMN is_public BOOLEAN NOT NULL DEFAULT true;
    ```
2.  **Added a status to `follows`**: This transforms the `follows` table from a simple link to a state machine for the relationship. We used a PostgreSQL `ENUM` for data integrity.

    ```sql
    -- First, create the custom type
    CREATE TYPE follow_status AS ENUM ('pending', 'accepted');

    -- Then, add the column to the table
    ALTER TABLE public.follows
    ADD COLUMN status follow_status NOT NULL DEFAULT 'accepted';
    ```
    Now, a row in `follows` can represent either an active follow (`accepted`) or a request (`pending`).

### 1.3. Securing with Row Level Security (RLS)

RLS is critical for ensuring users can only perform actions they are authorized to. We locked down the `follows` table to force complex actions through our secure RPCs.

**Final RLS Policies on `follows` Table:**
* **SELECT**: A user can see a follow relationship if it's `accepted`, OR if they are part of that relationship (either the follower or the one being followed). This protects the privacy of pending requests between other users.
* **INSERT / UPDATE**: **Disabled entirely (`WITH CHECK (false)`)**. This is a key security decision. It forces all creations and updates to go through our server-side RPC functions, where we can perform proper validation.
* **DELETE**: A user can delete a relationship if they are either the `follower` (to unfollow/cancel) or the `following_id` (to remove a follower/deny a request).

---

## 2. The Power of Server-Side Logic: PostgreSQL Functions (RPCs)

A major theme of our work was moving logic from the client to the server using RPC functions.

### 2.1. Why Use RPCs? A Best Practice Primer

* **Security**: The server securely determines `user_id` from `auth.uid()` and performs validation. The client only sends raw inputs, not fully-formed database objects.
* **Centralized Business Logic**: Rules like "can only have 3 active goals" or "gain 10 energy for this activity" are defined once on the server, not duplicated across multiple clients.
* **Performance & Efficiency**: Complex queries and multiple data fetches can be combined into a single network request, drastically reducing page load times.
* **Abstraction**: The client code becomes simpler (`supabase.rpc('create_goal', {...})`) and doesn't need to know the underlying database schema.

### 2.2. RPCs for Core Actions (Following & Goal Management)

We created a suite of functions to handle all data mutations securely.

**Example: Creating a Goal**
This function demonstrates server-side validation. It checks the user's `goal_slots` limit *before* creating the goal, something that is insecure to do only on the client.

```sql
-- RPC to securely create a goal
CREATE OR REPLACE FUNCTION create_goal(
    activity_id_input bigint,
    goal_description_input text,
    frequency_input smallint,
    start_date_input date
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    active_goal_count INT;
    max_goal_slots INT;
    new_goal public.goals;
BEGIN
    -- Server-side validation: Check for available goal slots
    SELECT p.goal_slots INTO max_goal_slots FROM public.profiles p WHERE p.id = auth.uid();
    SELECT count(*) INTO active_goal_count FROM public.goals WHERE user_id = auth.uid() AND is_active = true;

    IF active_goal_count >= max_goal_slots THEN
        RAISE EXCEPTION 'You have reached your maximum active goal slots.';
    END IF;

    -- Insert the new goal with server-set values
    INSERT INTO public.goals (...) VALUES (...) RETURNING * INTO new_goal;

    RETURN to_json(new_goal);
END;
$$;
```

### 2.3. RPCs for Advanced Data Fetching (Profiles & Search)

We used RPCs to create highly efficient data loaders.

**Loading a Full Profile (`get_profile_by_username`)**
This function became the workhorse for the profile page. It returns a single JSON object containing:
1.  The user's profile data.
2.  The relationship status in both directions (viewer -> target and target -> viewer).
3.  A list of active goals (if the viewer has access).
4.  A list of recent activities (if the viewer has access).

This was achieved using PostgreSQL's powerful JSON functions, like `jsonb_build_object` and `jsonb_agg`, to bundle all the data in a single database round trip.

```sql
-- Snippet from the final get_profile_by_username function
-- ... logic to determine is_full_access ...
IF is_full_access THEN
    -- Query for goals and aggregate into a JSON array
    SELECT COALESCE(jsonb_agg(...), '[]'::jsonb) INTO active_goals_json FROM ...;

    -- Query for activities and aggregate into a JSON array
    SELECT COALESCE(jsonb_agg(...), '[]'::jsonb) INTO activity_log_json FROM ...;

    -- Build the final, comprehensive JSON object
    result_data := jsonb_build_object(
      'id', ...,
      'username', ...,
      'viewer_follow_status', ...,
      'active_goals', active_goals_json,
      'activity_log', activity_log_json
    );
END IF;
```

**High-Performance User Search (`search_users`)**
We built an RPC to make searching fast and to return the data needed by the UI.
* **Performance:** We used the `pg_trgm` extension and a `GIN` index to enable incredibly fast "fuzzy" text search on the `username` and `display_name` columns.
* **Data Shaping:** The function returns the `is_public` flag along with user details, so the UI can display a lock icon for private profiles.

---

## 3. Client-Side Integration (React)

With our powerful backend functions in place, we refactored the client-side code to be much simpler and more robust.

### 3.1. The RPC-Driven Data Flow

The core pattern became:
1.  **On Page Load:** Call a single RPC function (e.g., `get_manage_goals_data`) to fetch all necessary data in one go.
2.  **On User Action:** Call a specific RPC function to perform an action (e.g., `create_goal`). The client doesn't build the database object; it just sends the raw user input.
3.  **Update UI:** Use the data returned from the RPC to optimistically or definitively update the React state.

### 3.2. Refactoring the `ProfilePage`

The `fetchUserData` function was transformed from a multi-request "waterfall" into a single, clean RPC call.

**Before:**
1.  `await supabase.auth.getUser()`
2.  `await supabase.from('...').select('username')`
3.  `await supabase.rpc('get_profile_by_username')`
4.  `await supabase.from('follows').select(...)` (to check follow status)
5.  `await supabase.from('goals').select(...)` (if access granted)
6.  `await supabase.from('activities').select(...)` (if access granted)

**After:**
1.  `await supabase.auth.getUser()`
2.  `await supabase.rpc('get_profile_by_username_with_everything')` (Our final, powerful function)
3.  `setProfileData(data)`

This change drastically improves performance and simplifies state management by eliminating race conditions and multiple sources of truth.

### 3.3. Refactoring the `ManageGoalsPage`

The handler functions were refactored to delegate all logic and validation to the server.

**Example: `handleCreateGoal`**
```javascript
// The refactored client-side handler
const handleCreateGoal = async (e) => {
    e.preventDefault();
    // No more client-side validation for goal_slots
    
    const { data, error } = await supabase.rpc('create_goal', {
        activity_id_input: newGoal.activity_id,
        goal_description_input: newGoal.goal_description,
        frequency_input: parseInt(newGoal.frequency),
        start_date_input: newGoal.start_date
    });

    if (error) {
        alert('Error: ' + error.message); // The server's error message is shown directly
    } else {
        // Update UI with the new goal returned from the server
        // ...
    }
};
```

---

## 4. Key Supabase Functionality & Debugging

We used several key Supabase/PostgreSQL features and debugged common issues.

### 4.1. Key Functionality
* **Row Level Security (RLS):** The cornerstone of Supabase security. We used it to define granular access rules.
* **PostgreSQL Functions (RPC):** Used to encapsulate all business logic on the server.
* **`pg_trgm` Extension:** Used to enable high-performance text search.
* **JSON Functions (`jsonb_agg`, `jsonb_build_object`):** Used to shape complex data responses efficiently on the server.

### 4.2. Debugging Common Errors

1.  **SQL Error: `column must appear in the GROUP BY clause...`**
    * **Cause:** An `ORDER BY` clause was placed outside a `jsonb_agg` aggregate function.
    * **Fix:** The `ORDER BY` must be placed *inside* the aggregate function: `jsonb_agg(... ORDER BY ...)` to ensure rows are sorted *before* being turned into a JSON array.

2.  **Network Error: `TypeError: Failed to fetch`**
    * **Cause:** A client-side network error, most commonly a **CORS (Cross-Origin Resource Sharing)** issue.
    * **Fix:** Ensure the URL the React app is running on (e.g., `http://localhost:3000`) is added to the CORS Configuration in your Supabase Project's API settings.

3.  **Data Type Error: `invalid input syntax for type uuid: "64"`**
    * **Cause:** A client-side data handling issue. We were merging a `goal` object (with a `uuid` id) and an `activity` object (with a numeric `id`) using the spread operator (`{ ...goal, ...activity }`). The numeric `id` from the activity was overwriting the `uuid` `id` from the goal in our React state.
    * **Fix:** Be explicit when merging objects. Instead of spreading the entire activity object, we destructured only the needed properties (`activity_label`, `activity_class`) to avoid the `id` property collision.


### Summary of Task: Building the `HomePage` Activity Feed

Our goal was to create a dynamic home feed that securely and efficiently displays recent activities from the user and the people they follow. We successfully achieved this by creating a powerful backend function and a clean frontend component to consume it.

#### 1. Backend: The `get_home_feed` RPC Function

We determined that a feed is a perfect use case for an RPC function due to the need to combine data from many tables (`activities`, `profiles`, `goals`, `follows`, etc.).

**The function we built accomplishes:**
* **Complex Joins:** It performs all the necessary `JOIN` operations on the server to gather profile details, activity information, and goal descriptions in a single query.
* **Core Feed Logic:** It uses a `WHERE` clause to filter for activities where the `user_id` is either the current user (`auth.uid()`) or is in the list of users they follow (`...IN (SELECT following_id FROM follows...)`).
* **Scalable Pagination:** It was designed with `LIMIT` and `OFFSET` parameters (`page_limit`, `page_offset`) from the start, allowing the client to fetch the feed in manageable chunks (e.g., 10 items at a time).
* **Data Shaping:** It returns a clean, predictable `TABLE` of data, perfectly shaped for what the UI needs to render.

```sql
-- The core logic of the get_home_feed RPC
SELECT a.id, p.username, ar.activity_label, g.goal_description, ...
FROM public.activities a
JOIN public.profiles p ON a.user_id = p.id
LEFT JOIN public.goals g ON a.goal_id = g.id
LEFT JOIN public.activity_reference ar ON a.activity_id = ar.id
WHERE
    -- The key filtering logic for the feed
    a.user_id = auth.uid() OR a.user_id IN (
        SELECT following_id FROM public.follows
        WHERE follower_id = auth.uid() AND status = 'accepted'
    )
ORDER BY a.timestamp DESC
LIMIT page_limit OFFSET page_offset;
```

#### 2. Frontend: The `HomePage.js` Component

We then refactored the React component to consume this new RPC endpoint.

* **Efficient Data Fetching:** The component now makes a single call to `supabase.rpc('get_home_feed', ...)` to get all the data it needs to render the feed, drastically reducing network requests.
* **Infinite Scroll / "Load More":** We implemented state for pagination (`page`) and a `handleLoadMore` function. This provides a modern user experience where new activities are appended to the list as the user scrolls or clicks a button.
* **Clean Rendering:** We created a sub-component (`ActivityCard`) to cleanly render each item in the feed, using the data returned by our RPC.
* **Dependency Management:** We finished by debugging a `Failed to resolve import` error, which was fixed by installing the `date-fns` package (`npm install date-fns`) to handle user-friendly date formatting.

#### 3. Security: Defense-in-Depth

Finally, we discussed the importance of having RLS policies on the underlying `activities` table as a "defense-in-depth" strategy. Even though the RPC is the primary way to access the data, this ensures that if a user ever tried to query the table directly, they would still be prevented from seeing activities they aren't supposed to.

In summary, we've built a performant, scalable, and secure foundation for your app's main social feed, all powered by a clean separation of concerns between the frontend and the backend.